#!/usr/bin/env python3

import sys
import os
import cv2
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import numpy as np
from time import sleep

# Todo features:
'''
use basename of input filename as basename.scad

-b option to print both image and inverted image.
translate by width + 3mm
or get really clever and determine whether height or width is shorter, 
and use the shorter side + 3mm as the offset. 

I did  it at hoome, but I forget what I did exactly. 
open a blank output file in openscad before creating the file. ...
this avoids the bug we found in openscad.

add a bulk processor

'''

DEFAULT_IMAGE = "t.png"
OUTPUT_SCAD = "output.scad"
PIXEL_SIZE = 1
MAX_HEIGHT_DEFAULT = 40.0
DOWNSCALE = 1


def generate_scad(image_array, output_path, pixel_size, max_height, threshold=3):
    data = image_array[::DOWNSCALE, ::DOWNSCALE]
    zscale = max_height / 255.0
    heights = data * zscale
    rows, cols = heights.shape

    with open(output_path, "w") as f:
        f.write("// Generated by img2stamps.py\n")
        f.write(f"// Downscaled to: {cols} x {rows}\n")
        f.write("union() {\n")
        for y in range(rows):
            for x in range(cols):
                h = heights[y, x]
                if h >= threshold:
                    h = 6
                    f.write(f"  translate([{x * pixel_size}, {y * pixel_size}, 0])\n")
                    f.write(f"    cube([{pixel_size}, {pixel_size}, {h:.2f}]);\n")
        f.write("}\n")
        f.write(f"color(\"white\")\n  cube([{cols * pixel_size}, {rows * pixel_size}, 3]);\n")
    print(f"Done. Output written to: {output_path}")

def generate_negative_scad(image_array, output_path, pixel_size, max_height, threshold=3):
    data = image_array[::DOWNSCALE, ::DOWNSCALE]
    zscale = max_height / 255.0
    heights = data * zscale
    rows, cols = heights.shape

    with open(output_path, "w") as f:
        f.write("// Generated by img2stamps.py\n")
        f.write(f"// Downscaled to: {cols} x {rows}\n")
        f.write("union() {\n")
        for y in range(rows):
            for x in range(cols):
                h = heights[y, x]
                if h <= threshold:
                    h = 6
                    f.write(f"  translate([{x * pixel_size}, {y * pixel_size}, 0])\n")
                    f.write(f"    cube([{pixel_size}, {pixel_size}, {h:.2f}]);\n")
        f.write("}\n")
        f.write(f"color(\"white\")\n  cube([{cols * pixel_size}, {rows * pixel_size}, 3]);\n")
    print(f"Done. Output written to: {output_path}")


def camera_capture_gui():
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        print("Error: Cannot access the camera.")
        return

    root = tk.Tk()
    root.title("Camera Capture for OpenSCAD")

    label = tk.Label(root)
    label.pack()

    height_slider = ttk.Scale(root, from_=1, to=20, orient="horizontal", value=MAX_HEIGHT_DEFAULT)
    height_slider.pack(fill="x", padx=10)
    height_label = tk.Label(root, text=f"Max Height: {MAX_HEIGHT_DEFAULT:.1f} mm")
    height_label.pack()

    def update_slider(val):
        height_label.config(text=f"Max Height: {float(val):.1f} mm")

    height_slider.config(command=update_slider)

    def capture():
        ret, frame = cap.read()
        if ret:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            generate_scad(gray, OUTPUT_SCAD, PIXEL_SIZE, float(height_slider.get()))
            sleep(5)
            #root.destroy()

    capture_button = tk.Button(root, text="Capture and Generate SCAD", command=capture)
    capture_button.pack(pady=10)

    def update():
        ret, frame = cap.read()
        if ret:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            img = ImageTk.PhotoImage(image=Image.fromarray(gray))
            label.imgtk = img
            label.configure(image=img)
        root.after(30, update)

    update()
    root.mainloop()
    cap.release()
    cv2.destroyAllWindows()

def main():
    args = sys.argv[1:]
    use_camera = "-c" in args
    use_negative = "-n" in args

    if use_camera:
        camera_capture_gui()
        return

    INPUT_IMAGE = DEFAULT_IMAGE
    for arg in args:
        if not arg.startswith("-"):
            INPUT_IMAGE = arg

    if not os.path.isfile(INPUT_IMAGE):
        print(f"Usage: {sys.argv[0]} [-c] [-n] [imagefile.png]")
	print("  -B : Bulk process images")
        print("  -b : print BOTH print a matched pair: inverted and non inverted models")        
	print("  -c : Capture from camera")
        print("  -n : Invert highs and lows")
        print(f"  Default file '{DEFAULT_IMAGE}' not found." if INPUT_IMAGE == DEFAULT_IMAGE else f"  File '{INPUT_IMAGE}' not found.")
	print(f"{sys.argv[0]} Works best on high contrast, or black and white images.")
	print("Images over 600x480 px may take an exceeding long time to process and render.")
        sys.exit(1)

    img = Image.open(INPUT_IMAGE).convert("L")
    width, height = img.size
    print(f"Original image size: {width} x {height}")
    data = np.array(img)

    if use_negative:
        generate_negative_scad(data, OUTPUT_SCAD, PIXEL_SIZE, MAX_HEIGHT_DEFAULT)
    else:
        generate_scad(data, OUTPUT_SCAD, PIXEL_SIZE, MAX_HEIGHT_DEFAULT)


if __name__ == "__main__":
    main()
